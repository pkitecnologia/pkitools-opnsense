#!/usr/local/bin/python3
"""
getchecksheet - Fetch network check configuration from Google Sheets

Usage:
  getchecksheet <api_key> <spreadsheet_id> <check_type> [sheet_range]

  api_key: Google Sheets API key
  spreadsheet_id: Google Sheets spreadsheet ID (from URL)
  check_type: Filter by CheckType column value (TCP or ICMP)
  sheet_range: Optional sheet range (default: Sheet1)

  The hostname is automatically detected from the system and used to filter
  by the 'Hostname' column in the spreadsheet.

Output:
  JSON array suitable for Zabbix LLD discovery rules
  Columns are auto-detected from the first row of the spreadsheet
"""

import json
import socket
import sys
import urllib.request
import urllib.error
import ssl


def fetch_sheet_data(spreadsheet_id, api_key, sheet_range='Sheet1'):
    """Fetch data from Google Sheets using API v4."""
    # Build API URL
    base_url = 'https://sheets.googleapis.com/v4/spreadsheets'
    url = f'{base_url}/{spreadsheet_id}/values/{sheet_range}?key={api_key}'

    try:
        # Create SSL context
        context = ssl.create_default_context()

        # Make request
        with urllib.request.urlopen(url, context=context, timeout=10) as response:
            data = json.loads(response.read().decode('utf-8'))

        # Extract values from response
        if 'values' not in data:
            print("Error: No data found in spreadsheet", file=sys.stderr)
            sys.exit(1)

        return data['values']

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8')
        print(f"HTTP Error {e.code}: {error_body}", file=sys.stderr)
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"URL Error: {e.reason}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error fetching spreadsheet: {e}", file=sys.stderr)
        sys.exit(1)


def parse_sheet_data(values, hostname, check_type):
    """Parse sheet data and filter by Hostname and CheckType."""
    if not values or len(values) < 2:
        print("Error: Spreadsheet must have at least a header row and one data row", file=sys.stderr)
        sys.exit(1)

    # First row contains headers
    headers = values[0]

    # Find column indices for required fields
    try:
        hostname_idx = headers.index('Hostname')
    except ValueError:
        print("Error: 'Hostname' column not found in spreadsheet", file=sys.stderr)
        sys.exit(1)

    try:
        check_type_idx = headers.index('CheckType')
    except ValueError:
        print("Error: 'CheckType' column not found in spreadsheet", file=sys.stderr)
        sys.exit(1)

    try:
        check_name_idx = headers.index('CheckName')
    except ValueError:
        print("Error: 'CheckName' column not found in spreadsheet", file=sys.stderr)
        sys.exit(1)

    try:
        check_host_idx = headers.index('CheckHost')
    except ValueError:
        print("Error: 'CheckHost' column not found in spreadsheet", file=sys.stderr)
        sys.exit(1)

    # CheckPort is optional for ICMP, so we find it but don't require it
    try:
        check_port_idx = headers.index('CheckPort')
    except ValueError:
        check_port_idx = None

    # Filter and build result
    results = []
    seen_checks = set()  # Track (hostname, checkname, checktype) to detect duplicates

    for row_num, row in enumerate(values[1:], start=2):  # Skip header row, start=2 for line numbering
        # Skip empty rows
        if not row:
            continue

        # Pad row with empty strings if it's shorter than headers
        while len(row) < len(headers):
            row.append('')

        # Check filters
        row_hostname = row[hostname_idx] if hostname_idx < len(row) else ''
        row_check_type = row[check_type_idx] if check_type_idx < len(row) else ''

        # Apply filters (case-insensitive comparison)
        if row_hostname.strip().lower() != hostname.lower():
            continue
        # Check if the requested check_type is in the row's CheckType (supports comma-separated values)
        if check_type.upper() not in row_check_type.strip().upper():
            continue

        # Build output object with all columns
        result = {}
        for i, header in enumerate(headers):
            value = row[i] if i < len(row) else ''
            result[header] = value.strip()

        # Validation: Check for required fields
        check_name = result.get('CheckName', '').strip()
        check_type_val = result.get('CheckType', '').strip()
        check_host = result.get('CheckHost', '').strip()
        check_port = result.get('CheckPort', '').strip() if check_port_idx is not None else None

        # Skip if CheckName is empty
        if not check_name:
            print(f"Warning: Skipping row {row_num}: CheckName is empty", file=sys.stderr)
            continue

        # Skip if CheckType is empty
        if not check_type_val:
            print(f"Warning: Skipping row {row_num}: CheckType is empty", file=sys.stderr)
            continue

        # Skip if CheckHost is empty
        if not check_host:
            print(f"Warning: Skipping row {row_num}: CheckHost is empty", file=sys.stderr)
            continue

        # Skip if CheckPort is empty when CheckType contains TCP
        if 'TCP' in check_type_val.upper():
            if check_port_idx is None:
                print(f"Warning: Skipping row {row_num}: CheckPort column not found but required for TCP checks", file=sys.stderr)
                continue
            if not check_port:
                print(f"Warning: Skipping row {row_num}: CheckPort is empty for TCP check", file=sys.stderr)
                continue

        # Duplicate detection: Check if this combination already exists
        check_key = (row_hostname.strip().lower(), check_name.lower(), check_type.upper())
        if check_key in seen_checks:
            print(f"Warning: Skipping row {row_num}: Duplicate check (Hostname={row_hostname.strip()}, CheckName={check_name}, CheckType={check_type.upper()})", file=sys.stderr)
            continue

        # Mark this combination as seen
        seen_checks.add(check_key)

        # Add to results
        results.append(result)

    return results


def main():
    """Main entry point."""
    # Parse command line arguments
    if len(sys.argv) < 4:
        print("Usage: getchecksheet <api_key> <spreadsheet_id> <check_type> [sheet_range]", file=sys.stderr)
        print("  api_key: Google Sheets API key", file=sys.stderr)
        print("  spreadsheet_id: Google Sheets spreadsheet ID (from URL)", file=sys.stderr)
        print("  check_type: Filter by CheckType column value (TCP or ICMP)", file=sys.stderr)
        print("  sheet_range: Optional sheet range (default: Sheet1)", file=sys.stderr)
        print("", file=sys.stderr)
        print("  Hostname is automatically detected from the system", file=sys.stderr)
        sys.exit(1)

    api_key = sys.argv[1]
    spreadsheet_id = sys.argv[2]
    check_type = sys.argv[3]
    sheet_range = sys.argv[4] if len(sys.argv) > 4 else 'Sheet1'

    # Get hostname from the system
    hostname = socket.gethostname()

    # Fetch data from Google Sheets
    values = fetch_sheet_data(spreadsheet_id, api_key, sheet_range)

    # Parse and filter data
    results = parse_sheet_data(values, hostname, check_type)

    # Output JSON
    print(json.dumps(results, indent=2))


if __name__ == '__main__':
    main()
